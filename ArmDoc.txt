通用寄存器

37个寄存器，31个通用寄存器，6个状态寄存器，R13堆栈指针sp，R14返回指针，R15为PC指针, cpsr_c代表的是这32位中的低8位，也就是控制位
R13堆栈指针sp:
	1) 保存现场；
		(1) 指 CPU 运行的时候，用到了一些寄存器，比如 r0,r1 等等，对于这些寄存器的值，在函数调用之前，应该将这些寄存器等现场，暂时保持起来(入栈 push)，等调用函数执行完毕返回后(出栈 pop)，再恢复现场。
		(2) 其中保存的寄存器中，也包括 lr 的值（因为用 bl 指令进行跳转的话，那么之前的 PC 的值是存在 lr 中的），然后在子程序执行完毕的时候，再把栈中的 lr 的值 pop 出来，赋值给 PC，这样就实现了子函数的正确的返回
	2) 传递参数: 
		(1) 汇编代码调用 C 函数时，需传递参数；
		(2) 本身传递的参数不多于 4 个，就可以通过寄存器 r0~r3 传送参数;
		(3) 参数多于 4 个时，寄存器不够用，就得用栈了。
	3) 保存临时变量:
		(1) 包括函数的非静态局部变量以及编译器自动生成的其他临时变量；
连接寄存器LR（r14）：
	1）保存子程序返回地址：
		使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：
						MOV PC, LR 
                        BX LR
    2）当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断

R15为PC指针：
	1）PC指向但前指令的下两条指令的地址，其值为当前指令地址的值加8
	2）使用STR/STM保存R15时，保存的可能是当前指令的地址值加8，也可能是当前指令的地址值加12
未备份寄存器：R0--R7。
备份寄存器：
	R8--R9，每个寄存器对应两个不同的2物理寄存器；
	R13-R14:每个寄存器对应6个不同的物理寄存器
寄存器CPSR:
	1) “当前程序状态寄存器”，
	2) CPSR中一些位被用于标识各种状态，一些位被用于标识当前处于什么工作模式。
	四种标志位：
	1）条件标志位
	2）Q标志位
	3）CPSR中的控制位
		T控制位：说明本指令时arm指令还是thumb指令
存储空间：
2^32个8字节／2^30个字／2^31个半字
big-edian：高字节在低地址

第二章 ArM指令集介绍

arm 指令格式：
cond：28-31，共2^4个
数据处理指令的操作数寻址
	1）立即数方式
	2）寄存器方式
		MOV R3,R2   //R3 = R2
		ADD R0,R1,R2  //R0 = R1 + R2
	3)寄存器移位方式
	ASR
	LSL
	LSR
	ROR
	RRX


第三章 Arm指令集
1，跳转指令
	1）长跳转：
		·向PC寄存器中写入目标地址
		·MOV LR PC：实现子程序调用
	2）32MB地址空间跳转
		B：目标指令时ARM指令，仅执行跳转
		BL：目标指令时ARM指令，执行跳转，同时将PC寄存器起的值保存到LR寄存器
		BLX：
			（1）BLX(1):目标指令是Thumb指令，同时将PC仅存起的值保存到LR寄存器；无条件执行指令
			（2）BLX(2)：
					·目标指令是ARM指令或者Thumb指令，
					·目标地址存放在Rm中；
					·目标地址的指令类型由CPSR的T为决定；
						ARM: <Rm>中的bit[0] == 0
						Thumb: <Rm>中的bit[0] == 1
					·同时将PC寄存器的值保存到LR寄存器；
		BX：
			(1) 目标指令是ARM指令或者Thumb指令
			(2)	目标地址的值 = <Rm> AND 0XFFFFFFFF
			(3) 目标地址的指令类型由CPSR的T为决定；
						ARM: <Rm>中的bit[0] == 0
						Thumb: <Rm>中的bit[0] == 1


